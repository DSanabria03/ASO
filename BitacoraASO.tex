\documentclass[10pt]{article}

% Idioma y codificación
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

% Márgenes
\usepackage{geometry}
\geometry{top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm}

% Gráficos
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{wrapfig}
\usepackage{float}

% Listings para código
\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{capt-of}
\lstdefinestyle{terminal}{
	backgroundcolor=\color{gray!10},
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue},
	commentstyle=\color{gray},
	frame=single,
	columns=fullflexible,
	morecomment=[l]{//}
}
\usepackage{listings}
\lstset{
	inputencoding=utf8,
	extendedchars=true,
	literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {ñ}{{\~n}}1
}

% Hipervínculos
\usepackage[hidelinks]{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=magenta,
	urlcolor=cyan,
}

\usepackage{url}

% Encabezados y pies de página
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[R]{\thepage}

% Formato de títulos
\usepackage{titlesec}
\titleformat{\subsection}{\normalfont\large\bfseries}{\hspace{1em}\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalfont\normalsize\bfseries}{\hspace{2em}\thesubsubsection}{1em}{}

% Datos de la portada
\title{\textbf{Cuaderno de bitácora}}
\author{\textbf{\small Daniel Sanabria Salamanqués}}
\date{\today}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\begin{document}
	
	\begin{titlepage}
		\centering
		\includegraphics[scale=0.3]{uva-3881270087.pdf}\\[0.5cm]
		\rule{\linewidth}{0.2mm}\\[0.4cm]
		{\huge\bfseries \thetitle}\\
		\rule{\linewidth}{0.2mm}\\[1.5cm]
		{\Large\bfseries Ingeniería Informática}\\[0.3cm]
		{\Large\bfseries Tecnologías de la Información}\\[1cm]
		{\Large \theauthor}\\[1.5cm]
		{\Large \thedate}
	\end{titlepage}
	
	\renewcommand{\contentsname}{Índice}
	\tableofcontents
	\clearpage
	\section{Instalación}
	
	\subsection{Clúster de Máquinas Virtuales}
	Para comenzar con la instalación, me dirijo a la página \url{matrix.inf.uva.es} e inicio sesión con mi cuenta de laboratorio de la escuela. Una vez hecho, observo que en el \verb|Datacenter| se encuentra mi máquina virtual \verb|vm3803.virtual.lab.inf.uva.es|. Al hacer doble clic, compruebo en la sección de \verb|Hardware| si está en el apartado \verb|CD/DVD| la imagen de \verb|Ubuntu Server|. Como no aparece, hago clic sobre ese apartado y con la opción \verb|Edit| que aparece en la parte superior, agrego la imagen a ese disco de la máquina.
	
	\subsection{Configuración de instalación}
	Tras esto, voy a la sección \verb|Console| para iniciar la máquina virtual y comenzar con la instalación de \verb|Ubuntu Server|. Lo primero es seleccionar el idioma para el sistema; en mi caso, escojo inglés. Después, indico que no quiero realizar la actualización para obtener \verb|Ubuntu Server 25.04|. Luego, para la configuración del teclado, selecciono el teclado español, debido a que mi teclado necesita esa configuración. En la siguiente pantalla, escojo que la instalación base será \verb|Ubuntu Server| por defecto y sin opciones adicionales. En la configuración de red, no modifico ningún valor ni agrego ningún \verb|proxy|. En cuanto al almacenamiento, indico que para la instalación use todo el disco y que no lo monte como un grupo \verb|LVM|. Después de confirmar la configuración del almacenamiento, relleno en la siguiente pantalla los datos de mi perfil:
	\begin{itemize}
		\item \textbf{Nombre}: Daniel
		\item \textbf{Nombre de servidor}: vm3803
		\item \textbf{Username}: dansana
	\end{itemize}
	Para la configuración de la conexión SSH, selecciono la opción de que se instale \verb|OpenSSH|. Para terminar, no agrego ninguna \verb|snap| al sistema y después de seleccionar \verb|Done|, dejo que se termine la instalación con la configuración seleccionada. Tras unos minutos, la instalación termina y reinicio el sistema.\\\\
	Una vez que ha arrancado, inicio sesión con el usuario y la contraseña que he creado y, acto seguido, procedo a purgar ciertas aplicaciones que no son necesarias.
	
	\subsection{Reconocimiento del entorno}
	Nos piden realizar un reconocimiento del entorno para conocer acerca del sistema que hemos instalado, además de saber cómo funciona la máquina virtual en la página \url{matrix.inf.uva.es}:
	\begin{itemize}
		\item \textbf{Version Kernel Linux}: El comando \verb|cat /proc/version|, nos devuelve la información acerca del Linux instalado. En este caso, se trata de un Linux con la versión el kernel 6.8.0-79-generic. El funcionamiento del comando es mostrar lo que contiene el archivo \verb|version| dentro de \verb|proc|, que se trata del sistema de ficheros. Otra opción, es con el comando \verb|uname| que muestra información del sistema dependiendo de la opción que se le pase como argumento.
		\item \textbf{Particiones}: Con el comando \verb|df -h|, se obtiene las particiones montadas. En este caso, tenemos las siguientes particiones:
		\begin{itemize}
			\item \textit{/dev/sda1}: Montada en el directorio \verb|/boot/efi| y es la encargada de el arranque del sistema. 
			\item \textit{/dev/sda2}: Montada en el directorio raíz \verb|/|, dedicada al resto de sistema.
		\end{itemize}
		\item \textbf{Espacio libre}: Con el mismo comando que el punto anterior, se puede ver que hay varias columnas dedicadas al almacenamiento de cada partición:
		\begin{itemize}
			\item \textit{/dev/sda1}: Con \verb|1.1G| en total, solo se ha usado el 1\%, es decir, \verb|6.2M| se ha utilizado y se encuentran disponibles \verb|1.1G| para usar.
			\item \textit{/dev/sda2}: Con \verb|58G| en total, solo se ha usado el 12\%, es decir, \verb|6.5G| se ha utilizado y se encuentran disponibles \verb|49G| para usar.
		\end{itemize}
		\item \textbf{Cerrar sesión}: Cuando se ha iniciado sesión y queremos cerrar esa misma sesión, simplemente tenemos que escribir el comando \verb|logout| y el sistema cerrará la sesión.
		\item \textbf{Apagar la máquina}: Desde la consola del sistema, mediante el comando \verb|shutdown -h| se le enviará una señal al sistema para apagar la máquina, deteniendo todos los procesos y sincronizando los discos. Si queremos hacerlo inmediato, añadimos \verb|now| al lado de \verb|shutdown|.
		\item \textbf{Reiniciar la máquina}: Para el reinicio inmediato, se emplea el comando \verb|reboot|, o, para un reinicio programado, se emplea \verb|shutdown -r|.
		\item \textbf{Controles de la consola de la máquina virtual}: Se pide usar los controles que aparecen en la parte superior:
		\begin{enumerate}
			\item Cuando la máquina esté encendida, nos indican apagar la máquina con \verb|Stop|. Esto obligará a la máquina a hacer un apagado forzado.
			\item Después de volver a encender, nos piden restear la máquina mediante la opción \verb|Reset|. Funciona igual que escribir el comando \verb|reboot|.
			\item Por último, será apagar de nuevo la máquina pero con la opción \verb|Shutdown| que le envía una señal \verb|ACPI| al sistema operativo.
		\end{enumerate}
	\end{itemize}
	
	\subsection{Acceso remoto vía ssh}
	Se nos indica que el sistema ya tiene instalado y activado el servicio de conexión segura \verb|sshd| (que previamente hemos configurado en la configuración de la instalación) y para comprobar que funciona correctamente, me conectaré desde \verb|Jair| a esta máquina, usando la red de la UVa. Aquí se muestra una captura del proceso:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.6\linewidth]{Recursos/ssh.png}
	\end{figure}
	
	\subsection{Activar cuenta root}
	Lo siguiente que se indica es activar la cuenta \verb|root| cambiando su contraseña mediante \verb|sudo passwd root| e indicando una clave para ese usuario y así poder acceder a la consola directamente como \verb|root|, ya que por defecto no trae ninguna contraseña y puede ser una brecha de seguridad.
	
	\subsection{Administración del disco}
	Se pide obtener información sobre las particiones lógicas y física de nuestra máquina virtual, con ayuda de los comandos que se explican en las transparencias. 
	Y para saber el sistema de ficheros que se está utilizando, tendremos que hacer un \verb|cat| al fichero \verb|/etc/fstab|, que contiene las informaciones que conciernen al montaje de las particiones que hay en el sistema.
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.5\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/particiones.png}
		\end{minipage}\hfill
		\begin{minipage}{0.45\textwidth}
			\begin{itemize}
				\item \textbf{Dispositivos}: Tal y como se muestra en la imagen, solo tenemos un dispositivo de almacenamiento \verb|sda| con una capacidad de 60G. El otro dispositivo que existe es el CD de instalación de \verb|Ubuntu Server| que ocupa 2.6G.
			\end{itemize}
		\end{minipage}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.5\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/fstab.png}
		\end{minipage}\hfill
		\begin{minipage}{0.45\textwidth}
			\begin{itemize}
				\item \textbf{Particiones}: Existen dos particiones en el disco \verb|sda|:
				\begin{itemize}
					\item \textit{sda1}: Con un tamaño de 1G y montado en el directorio \verb|/boot/efi|, es la encargada de almacenar las herramientas de arranque del sistema que serán lanzadas por el firmware UEFI. Emplea el sistema de ficheros \verb|vfat|.
					\item \textit{sda2}: Partición principal, anclado en el directorio \verb|/|, con el tamaño restante del disco para almacenar todas las aplicaciones y ficheros del sistema operativo y del usuario. Emplea el sistema de ficheros \verb|ext4|.
				\end{itemize}
			\end{itemize}
		\end{minipage}
	\end{figure}
	
	Después, se nos exige investigar el fichero \verb|/proc/filesystems| donde se ubican los sistemas de ficheros que es capaz de entender el sistema. \label{filesystems}
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.28\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/filesystems.png}
		\end{minipage}\hfill
		\begin{minipage}{0.7\textwidth}
			\begin{itemize}
				\item Se muestra dos columnas donde en la izquierda se indica si se requiere un dispositivo de bloque asociado al sistema de fichero que se muestra en la columna de la derecha.
				\item Por ejemplo, para los sistemas de ficheros \verb|ext2, ext3 o ext4| no se indica el valor \verb|nodev|, por lo que es necesario usar un dispositivo físico para usar ese sistema de fichero. Pero, para \verb|tmpfs o proc|, no es necesario tener un dispositivo físico.
			\end{itemize}
		\end{minipage}
	\end{figure}
	
	\subsubsection{Loop} \label{loop}
	Después, creamos un sistema de archivos o fichero dentro de un fichero nuevo:
	\begin{enumerate}
		\item Creamos el fichero mediante el comando \verb|dd|, donde se le indica los siguientes parámetros:\\
		\verb|dd if=/dev/zero of=fichero bs=1 count=4096|
		\begin{itemize}
			\item \textbf{if}: Desde que fichero o directorio se van a leer los datos. Como vamos a crear un fichero vacío, haremos uso de \verb|/dev/zero| que se trata de un fichero especial desde el que se obtiene un flujo de cero, con el propósito de inicializar un fichero.
			\item \textbf{of}: Indicamos la ruta con el nombre del fichero creado. 
			\item \textbf{bs}: Indicamos el tamaño del bloque que se quiere leer y escribir. Para este caso, se escoge de 1 MB por comodidad.
			\item \textbf{count}: El número de bloques que se van a crear. En este caso 4096M que corresponden a los 4G.
		\end{itemize}
		\item El siguiente paso es crear el dispositivo de bloque sobre el fichero que hemos creado con el que trabajaremos para crear el sistema de ficheros, mediante el comando \verb|losetup|:
		\begin{itemize}
			\item Antes de crearlo, tenemos que ver los dispositivos \verb|loop| que están disponibles para asociarlo con el fichero. Para ello, lanzamos el comando \verb|losetup -f| y nos devuelve que el único dispositivo disponible es \verb|/dev/loop0|.
			\item Ahora lo único que tenemos que hacer es ejecutar este comando \verb|sudo losetup /dev/loop0 fichero|. Es necesario usar permisos de administrador, por lo que se lanzará el comando con \verb|sudo|.
		\end{itemize}
		\item Con el dispositivo de tipo bloque, le asignamos un sistema de fichero cualquiera con \verb|mkfs|. En mi caso, le asigno el mismo que el que tiene la partición principal: \verb|sudo mkfs.ext4 /dev/loop0|.
		\item Lo último es montar ese sistema de fichero nuevo en un directorio (\verb|/mnt| debido a que está dedicado a montar dispositivos).
		\item Para comprobar que lo hemos montado correctamente, usamos el comando \verb|lsblk| para ver todas las particiones montadas.
	\end{enumerate}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.6\linewidth]{Recursos/loop0.png}
	\end{figure}
	
	Cuando tengamos el dispositivo de disco \verb|Loop|, nos piden administrar las particiones en ese dispositivo:
	\begin{itemize}
		\item Para crear una partición, haremos uso de la herramienta de \verb|fdisk|. No tendrá ningún valor específico, por lo que se deja todo por defecto.
		\item Puede ser que el kernel no pueda actualizar automáticamente la tabla de particiones al terminar, por lo que habrá que desanclar y volver anclar el \verb|Loop|.
		\item Al igual que hemos hecho con el dispositivo, habrá que formatear esa partición y asignarle un sistema de ficheros. En este caso el mismo que tiene el propio dispositivo.
		\item Después, se monta la partición con el comando \verb|mount| sobre el directorio \verb|/mnt| y se comprueba lanzando un \verb|df -h|. Tras esto, se desmonta con \verb|umount|.
		\item Ahora nos piden un resumen acerca de la función de los ficheros \verb|/etc/fstab| y \verb|/etc/mtab|:
		\begin{itemize}
			\item \textbf{/etc/fstab}: Es un fichero de configuración estático que define qué sistemas de archivos hay en el sistema y cómo deben montarse. La máquina lo consulta durante el arranque para montar automáticamente discos, particiones o sistemas de ficheros de red.
			\item \textbf{/etc/mtab}: Es un fichero dinámico, generado por el sistema, que refleja qué sistemas de ficheros están montados en este momento. En sistemas modernos, muchas veces /etc/mtab es un enlace simbólico a /proc/self/mounts, que cumple la misma función.
		\end{itemize}
		\item Por último, nos indican eliminar la partición existente en \verb|loop0| y crear varias particiones primarias y extendidas o lógicas. Además, cada partición tiene que tener un sistema de ficheros independiente. Este sería el esquema resultante:
		\begin{figure}[H]
			\centering
			\begin{minipage}{0.48\textwidth}
				\centering
				\includegraphics[width=\linewidth]{Recursos/particiones1.png}
			\end{minipage}\hfill
			\begin{minipage}{0.48\textwidth}
				\centering
				\includegraphics[width=\linewidth]{Recursos/particiones2.png}
			\end{minipage}
		\end{figure}
	\end{itemize}
	
	\subsubsection{LVM}
	Llegados a este punto, se requiere volver a destruir las particiones existentes para crear y administrar volúmenes lógicos (LVM).
	\begin{enumerate}
		\item Primero, modificamos la etiqueta de cada partición para marcar que es de tipo \verb|Linux LVM|. Desde la herramienta de \verb|fdisk|, seleccionamos cada partición del dispositivo \verb|loop0| y con la opción \verb|t|, escogemos el número 44 (en este caso que usamos una tabla de particiones de tipo \verb|GPT|).
		\item Después, creamos el volumen físico en cada partición con \verb|pvcreate|:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.6\linewidth]{Recursos/pvcreate.png}
		\end{figure}
		\item Lo siguiente, es crear un grupo de volúmenes físicos, con \verb|vgcreate|, donde agregamos los que hemos creado:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.6\linewidth]{Recursos/vgcreate.png}
		\end{figure}
		\item Por último, creamos un par de volúmenes lógicos, con \verb|lvcreate|, sobre ese grupo que hemos creado en el punto anterior para después montarlo en el sistema:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.6\linewidth]{Recursos/lvcreate.png}
		\end{figure}
		\item Una vez ya tenemos los volúmenes lógicos, los formateamos ambos para asignarles una estructura de directorios y los montamos en el directorio \verb|/mnt| para comprobar que se ha creado de forma correcta:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.6\linewidth]{Recursos/mountLVM.png}
		\end{figure}
		\item Para acabar con este apartado, retornamos el sistema a su estado anterior desmontando y eliminando los volúmenes: 
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.6\linewidth]{Recursos/removeLVM.png}
		\end{figure}
	\end{enumerate}
	
	\subsection{Administración de almacenamiento}
	\subsubsection{RAID 5}
	Lo último que vamos a hacer antes de realizar una nueva instalación es crear y administrar un \verb|RAID 5| mediante software:
	\begin{enumerate}
		\item Lo primero es crear 3 nuevos dispositivos \verb|loop| de la misma manera que lo hemos hecho en el apartado \hyperref[sec:loop]{Loop}:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.6\linewidth]{Recursos/fichRAID.png}
		\end{figure}
		Y después asociarlo a 3 dispositivos \verb|loop|:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.7\linewidth]{Recursos/loopRAID.png}
		\end{figure}
		\item Consultando el manual para crear el dispositivo \verb|RAID|, tenemos que seleccionar el modo \verb|Create|, con las opciones de:
		\begin{itemize}
			\item \verb|level|: Indicando el tipo de \verb|RAID|.
			\item \verb|raid-devices|: Número de dispositivos que usaremos.
		\end{itemize}
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.9\linewidth]{Recursos/createRAID.png}
		\end{figure}
		\item Ahora repetimos el mismo procedimiento que con el resto de dispositivos de almacenamientos para formatearlos y darle un sistema de ficheros y montarlo:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.6\linewidth]{Recursos/mountRAID.png}
		\end{figure}
	\end{enumerate}
	Para comprobar que hemos configurado correctamente el disco, ejecutamos el comando \\ \verb|echo “Voy a destruir el disco!!!!” > fichero.img| donde \verb|fichero.img| es uno de los ficheros que da soporte al \verb|RAID| para hacerlo fallar y ver que sigue funcionando. Al lanzarlo, veo que no se destruye el disco y sigue activo, debido a que el dispositivo \verb|RAID 5| está montado y funcionando. Entonces, lo que hay que hacer es reiniciar la máquina para que deje de estar en funcionamiento y lanzar el comando. 
	
	\subsection{Nueva instalación personalizada}
	Hasta ahora hemos trabajo con una configuración "por defecto" sobre la administración del disco de la máquina, teniendo únicamente dos particiones: \verb|/boot/efi| empleada para el arranque del sistema y \verb|/| para el resto de archivos del equipo. En un entorno real, tenemos más particiones para minimizar posibles fallos y errores, por lo que vamos a realizar una nueva instalación con las siguientes particiones:
	\begin{itemize}
		\item \verb|/boot/efi|: Contiene los ficheros para el arranque del sistema y tiene un espacio de \verb|1.049G|, que es lo que ocupaba inicialmente y no se puede modificar. El formato que tiene es \verb|fat32|, bastante antiguo y limitado, pero compatible con muchos dispositivos.
		\item \verb|/|: Destinado a todos los ficheros para el sistema operativo y con un espacio de \verb|15G| para que no haya problemas a la hora de agregar elementos al sistema.
		\item \verb|swap|: Con un espacio de \verb|1G|, solo actúa en caso de que la memoria RAM se quede sin espacio. No es necesario añadir nada más ya que el sistema ya cuenta con 6GB de RAM.
		\item \verb|/usr|: Donde se ubica los programas y librerías instaladas, por lo que es necesario \verb|15G| de almacenamiento.
		\item \verb|/var|: Lugar donde se ubican los ficheros como logs y colas. No es necesario dar mucho tamaño, por lo que se le asignan \verb|3GB|.
		\item \verb|/tmp|: Contiene archivos temporales y es necesario separarlo para que en caso de que se ocupe por completo, no bloquee el sistema. Solo es necesario \verb|5G|.
		\item \verb|/home|: Dedicada al espacio personal del usuario que ocupa el resto del espacio restante del disco.
	\end{itemize}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.6\linewidth]{Recursos/nuevaInstalacion.png}
	\end{figure}
	
	\subsection{Trabajo No Presencial}
	\begin{itemize}
		\item \textbf{Administración de discos – particiones}: 
		\begin{itemize}
			\item Los discos duros o dispositivos de bloques, se dividen en unidades lógicas llamadas \textit{particiones}.\cite{Discos}
			\item Una partición sirve para organizar y almacenar el sistema operativo, las aplicaciones y los archivos personales. Existen diferentes esquemas para la distribución de particiones en un disco, como MBR o GPT.
			\item Cada partición se representa como un archivo en el sistema de archivos de Linux y se encuentra ubicada en el directorio \verb|/dev|.
		\end{itemize}
		\item \textbf{Sistemas de archivos}: 
		\begin{itemize}
			\item Es un elemento que controla cómo se almacenan y recuperan los datos. Sin un sistema de archivos, los datos colocados en un medio de almacenamiento serían un gran cuerpo de datos sin manera de saber dónde termina un dato y comienza el siguiente. 
			\item Se organizan en una estructura jerárquica, de tipo árbol. El nivel más alto del sistema de ficheros es / o directorio raíz. Todos los demás ficheros y directorios están bajo el directorio raíz.\cite{Archivos}
			\item Por debajo del directorio raíz (/) hay un importante grupo de directorios común a la mayoría de las distribuciones de GNU/Linux: \verb|/bin, /boot, /etc/, /opt, etc|.
			\item Tipos de sistemas de ficheros más utilizados en la actualidad:
			\begin{itemize}
				\item \verb|EXT|: Con sus versiones \verb|ext2|, \verb|ext3| y \verb|ext4| (siendo esta la más usada en sistemas Linux), fue creado para sobrepasar las limitaciones de \verb|MINIX| y consiguió implementar \verb|VFS|.
				\item \verb|XFS|: Manejo de grandes volúmenes de datos, por lo que es muy usado en servidores y sistemas empresariales.
				\item \verb|NTFS|: Sistema principal de \verb|Windows| y con cierta compatibilidad con Linux.
				\item \verb|FAT32|: Antiguo y limitado, pero muy compatible con todos los sistemas.
				\item \verb|exFAT|: Evolución del anterior sistema y diseñado especialmente para memorias flash.
			\end{itemize}
		\end{itemize}
		\item \textbf{Actualización de un sistema operativo previamente instalado}:
		\begin{itemize}
			\item En el caso de nuestra máquina virtual, estamos trabajando con \verb|Ubuntu| que pertenece al grupo de distribuciones \verb|Debian|, por lo que para actualizar el sistema operativo una vez instalado se hará uso de la herramienta \verb|apt|.
			\item \verb|apt| nos proporciona un sistema de gestión de paquetes donde maneja automáticamente las dependencias para la instalación de esos paquetes. Requiere de privilegios administrativos.\cite{Actualizar}
			\item Para las actualizaciones será necesario usar los comandos \verb|sudo apt update| y \verb|sudo apt upgrade|.
		\end{itemize}
		\item \textbf{Identificación discos duros y particiones}:
		\begin{itemize}
			\item En Linux, los dispositivos se representan dentro del directorio \verb|/dev| y se identifican como dispositivos de bloques (\verb|sda, sdb, sdc, etc.| o \verb|nvme0n1, nvme0n2, nvme0n3, etc.|).
			\item Además, las particiones, tal y como se mencionaba en el primer apartado, son unidades lógicas de estos dispositivos y se identifican numerándose en orden seguido del nombre del dispositivo (\verb|sda1, sda2, sda3, etc.| o \verb|nvme0n1p1, nvme0n1p2, nvme0n1p3, etc.|).\cite{Discos}
			\item También, cada partición puede tener un \verb|UUID| único, que no cambia aunque el disco se conecte en distinto orden.
		\end{itemize}
		\item \textbf{RAID}: 
		\begin{itemize}
			\item \verb|RAID| o Redundant Array of Independent Disks hace referencia a un sistema de almacenamiento de datos que utiliza múltiples discos duros, entre las cuales se distribuyen o replican los datos. \cite{RAID}
			\item Estas son las principales configuraciones de \verb|RAID|:
			\begin{itemize}
				\item \textbf{RAID 0}: Distribuye los datos equitativamente entre dos o más discos sin información de paridad que proporcione redundancia. No tiene tolerancia a fallos, si falla un disco, lo pierdes todo.
				\item \textbf{RAID 1}: Crea una copia exacta de un conjunto de datos en dos o más discos. Puede fallar solo un disco para no perder todos los datos.
				\item \textbf{RAID 5}: División de datos a nivel de bloques que distribuye la información de paridad entre todos los discos miembros del conjunto. Esta variante de \verb|RAID| ha logrado popularidad gracias a su bajo coste de redundancia. Puede tolerar 1 disco defectuoso; reconstrucción en curso mientras funciona.
				\item \textbf{RAID 6}: amplía el nivel RAID 5 añadiendo otro bloque de paridad, por lo que divide los datos a nivel de bloques y distribuye los dos bloques de paridad entre todos los miembros del conjunto. Puede tolerar 2 discos defectuosos; más seguro que RAID 5 en entornos con discos grandes.
			\end{itemize}
		\end{itemize}
	\end{itemize}
	
	\clearpage
	
	\section{Administración de usuarios y servicios}
	\subsection{Gestión de usuarios y grupos}
	Para comprobar si la clave de nuestro usuario y el resto de usuarios está encriptada, tenemos que ver si en el fichero \verb|/etc/passwd|, dedicado a recopilar la información de un usuario, en el segundo campo aparece escrita la clave o se muestra en su lugar el carácter \verb|'x'|. Con solo lanzar un \verb|cat| a ese fichero, descubrimos que cada usuario tiene su clave encriptada:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.6\linewidth]{Recursos/passwd.png}
	\end{figure}
	Con esto concluimos que se está usando el fichero \verb|/etc/shadow| para contener la clave encriptada.\\\\
	Creamos dos nuevos grupos de usuario con \verb|addgroup| y dos usuarios para cada grupo con \verb|useradd|, para crearlos, y \verb|adduser|, para agregarlo a uno de los grupos:
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/userNuevos.png}
		\end{minipage}\hfill
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/groupNuevos.png}
		\end{minipage}
	\end{figure}
	Tras la creación de los nuevos usuarios y grupos, volvemos a ver el contenido del fichero \verb|/etc/passwd| y también de \verb|/etc/group|, que contiene información de cada grupo y los usuarios que hay dentro de él:
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/passwdNuevo.png}
		\end{minipage}\hfill
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/groupNuevo.png}
		\end{minipage}
	\end{figure}
	Y para el \verb|password| de cada usuario, lo recomendable es seguir estos consejos:
	\begin{itemize}
		\item \textbf{Longitud de la contraseña}: Debería haber entre 12 y 16 caracteres.
		\item \textbf{Uso de distintos tipos de caracteres}: Mezclar entre símbolos y letras mayúsculas y minúsculas, incluso números.
		\item \textbf{No utilizar secuencias conocidas}.
	\end{itemize}
	La siguiente tarea es tener una estructura de directorios/ficheros tipo en el directorio \verb|/etc/skel|, encargado de otorgar esa jerarquía al directorio \verb|/home/<user>|. Decidí dar una estructura parecida a la que otorga \verb|Ubuntu Desktop| en su instalación, usando \verb|mkdir|: 
	\begin{itemize}
		\item Downloads
		\item Documents
		\item Images
		\item Desktop
	\end{itemize}
	Al crear otro par de usuarios y agregarlos cada uno a los grupos nuevos, la estructura de ficheros de sus directorios \verb|/home| tendrá esa jerarquía:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.6\linewidth]{Recursos/skel.png}
	\end{figure}
	\clearpage
	
	\subsection{Gestión de password}
	Se puede establecer una fecha de caducidad a la contraseña de un usuario y de su cuenta con el comando \verb|chage| que estable dicho atributo. Hay que tener en cuenta que el sistema está 2 horas retrasado de la hora real (se puede comprobar con el comando \verb|date|). Para la contraseña, hay que usar la opción \verb|-M| para indicar el máximo de días que tiene esa contraseña antes de caducar, y la opción \verb|-E| indica la fecha tope de ese usuario:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/chage.png}
	\end{figure}
	Para comprobar que funciona, podemos verlo en el fichero \verb|/etc/shadow| ya que al tener la información de las claves de los usuarios, se indica también cuando es su fecha de espiración:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=\linewidth]{Recursos/shadowChage.png}
	\end{figure}
	
	\subsection{Gestión avanzada de grupos}
	Nos piden que uno de los nuevos usuarios creados forme parte de un de los dos grupos. Compruebo viendo el fichero \verb|/etc/group| que cada usuario está asignado a un grupo, por lo que únicamente habrá usar \verb|usermod| con las opciones \verb|-aG| para añadir a ese usuario a un grupo a mayores. En mi caso lo pruebo con el usuario \verb|user4|.
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.6\linewidth]{Recursos/user2group.png}
	\end{figure}
	Una de las ventajas de tener un usuario en varios grupos puede darse a la hora de asignar permisos sobre un recurso compartido, ya que un solo usuario puede tener acceso y privilegios a recursos de ambos grupos.
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/ejemploGroup.png}
	\end{figure}
	\clearpage
	A mayores, tenemos que asignarle una clave a un grupo, con \verb|sudo gpasswd group|. En la captura podemos ver la clave encriptada del \verb|grupo1|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/gshadow.png}
	\end{figure}
	Esto puede tener varias ventajas, entre ellas el acceso temporal a los recursos que puede tener ese grupo, de forma que el administrador no tiene que estar agregando o excluyendo usuarios del grupo.
	
	\subsection{Perfiles de usuario}
	En este apartado, se pide modificar la configuración del editor de texto \verb|vi|, de forma que para uno de los usuarios creados (por ejemplo \verb|user4|) se realicen dos operaciones automáticamente cuando se abra el programa, por lo que será necesario modificar el archivo con la configuración de este editor.\\\\
	Como ya se ha comentado en la instalación, estamos usando \verb|Ubuntu Server 24| en nuestras máquinas virtuales y, consultando la información en foros \cite{rcfile}, en sistemas modernos, utiliza el mismo fichero de configuración que \verb|vim| que es \verb|.vimrc|, porque el comando \verb|vi| es un enlace simbólico al editor \verb|vim|.
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/viVim.png}
	\end{figure}
	En \verb|/home/user4|, no existe ese fichero de configuración, por lo que habrá que crearlo y agregar las opciones requeridas.
	\begin{itemize}
		\item Para la auto-sangría, tenemos que activar la opción \verb|autoindent|.
		\item Y para un máximo de 75 caracteres con un salto de línea, la opción \verb|textwidth=75 linebreak|.
	\end{itemize}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/vimrc.png}
	\end{figure}
	Las dos últimas líneas son configuración adicional que he añadido para agregar color al texto y que aparezcan los números de línea por pantalla.
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/pruebaVi.png}
	\end{figure}
	\clearpage
	
	Finalizado esta primera personalización, ahora nos piden que cada vez que el usuario inicie sesión, se muestre el contenido de \verb|$HOME/docs/Agenda.txt|. Haciendo uso de \verb|Shell scripting|, modificamos el fichero \verb|.profile| porque es el que se ejecuta cuando se inicia sesión en un usuario:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/profile.png}
	\end{figure}
	Reiniciando, veremos lo que hay escrito en \verb|Agenda.txt| ubicado en la última línea de todo el contenido que se muestra tras iniciar sesión.
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/inicioProfile.png}
	\end{figure}
	\clearpage
	
	También, se requiere que cunado el usuario abre un \verb|shell|, se muestre la fecha y hora del último login. En este caso, el fichero \verb|.bashrc| es el que contiene la configuración de cualquier \verb|shell|. Al final del fichero, agregamos \verb|lastlog -u "$USER"| con \verb|tail -n 1|, donde \verb|lastlog| es el comando que muestra el login más reciente de un usuario y \verb|tail| es para mostrar solo la última línea del registro.
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/bashrc.png}
	\end{figure}
	Al estar una máquina virtual, no estamos interactuando con una \verb|tty|  "real", por lo que nunca se registrará el inicio de sesión.
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/lastlog.png}
	\end{figure}
	Y, finalmente, la última personalización es que cada vez que se cierre sesión, se muestre un mensaje de despedida y solo se cierre sesión tras haber respondido al mensaje. Al hacer \verb|logout|, el sistema ejecuta el fichero \verb|.bash_logout| con todas las instrucciones que contiene. Por ello, modificamos dicho archivo para que mediante un \verb|echo| muestre el mensaje y se quede esperando con un \verb|read|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/logout.png}
	\end{figure}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/logout1.png}
	\end{figure}
	\clearpage
	
	\subsection{Servicios del sistema}
	En este apartado, se trabajará acerca de los servicios que hay en el sistema, destacando el de conexión segura o \verb|ssh|. Para comprobar los servicios activos, lanzamos el comando \\ \verb|systemctl list-units --type=service --state=running| donde señalamos que en el listado de servicios nos interesa aquellos que están activos:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/activeProcess.png}
	\end{figure}
	Cada proceso nos indica el nombre (\verb|UNIT|), si está cargado en el sistema (\verb|LOAD|), si está activo (\verb|ACTIVE|), su estado (\verb|SUB|) y una descripción (\verb|DESCRIPTION|). Observando la lista, vemos que no aparece el servicio \verb|ssh| porque está inactivo:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/statusSSH.png}
	\end{figure}
	Vemos que está desactivado, por lo que habrá que activarlo con \verb|sudo systemctl enable ssh|, después se para con el mismo comando pero usando \verb|stop| en vez de \verb|enable|, y se iniciará con \verb|start|.
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/sshService.png}
	\end{figure}
	Es esencial tener un equipo con los servicios esenciales activos y desactivar aquellos que no tienen mucha relevancia, ya que consumen recursos innecesarios y pueden llegar a ser un riesgo en la seguridad. Investigando el listado de servicios que hay activos en mi máquina, hay ciertos servicios que se pueden quitar como \verb|ModemManager.servicie| debido a que solo se emplea para la gestión de módems 3G/4G.\\\\
	Y para terminar con esta sección, nos piden que el sistema desde el arranque vaya al nivel de ejecución 3 (\verb|runlevel3|), es decir sin entorno gráfico y solo en modo texto con red. Dependiendo de cada \verb|runlevel| entre 1 y 5, Linux se ejecutará de una forma distinta. Para arrancar como ese nivel de ejecución \verb|sudo systemctl set-default multi-user.target| \label{target}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.9\linewidth]{Recursos/runlevel.png}
	\end{figure}
	
	\subsection{Permisos de acceso}
	Vamos a aprender acerca de cómo funcionan los permisos en sistemas Linux \cite{umask}. En los sistemas operativos tipo \verb|POSIX| cada elemento del sistema de archivos tiene la característica de poseer permisos que lo ubican dentro del mismo. Éstos sirven como uno más de los niveles de seguridad del sistema operativo al impedir que cualquier usuario pueda leer, escribir, ejecutar o acceder a dichos archivos y directorios de manera arbitraria. Estos permisos vistos de manera básica son: lectura (r, \verb|read|), escritura (w, \verb|write|) y ejecución (x, \verb|execution|) y se agrupan en bloques (\verb|rwx|) para 3 diferentes clases (usuario, grupo y otros).\\\\
	Por defecto, cuando se crea un elemento en el sistema de fichero, se le asignará unos permisos dependiendo del objeto creado. \verb|umask| es una función que establece los permisos predeterminados para los nuevos archivos y directorios creados en el sistema. El valor de la máscara de usuario, que se asigna ejecutando \verb|umask|, corresponde a los bits contrarios del permiso predeterminado que se quiera asignar. Es decir, si por ejemplo se quiere asignar una máscara de usuario equivalente a 0775 (\verb|rwxrwxr-x|), el valor de la máscara de usuario corresponderá a 0002 (el resultado de la operación 777 menos 775), que será lo mismo que definir \verb|u=rwx,g=rwx,o=rx|. En este caso, para lograr que cuando se cree un fichero tenga los permisos 550, tenemos que saber que los permisos por defecto son 664 y realizar el siguiente cálculo: \verb|550 = 664 - umask|. El resultado de \verb|umask| es 114 en octal. Para aplicarlo a todos los usuarios, tenemos que agregar al final del fichero \verb|/etc/profile| esta línea \verb|umask 114|.
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/etcProfile.png}
		\end{minipage}\hfill
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/umaskPrueba.png}
		\end{minipage}
	\end{figure}
	\clearpage
	
	Acerca del bit \verb|SetUID|, es un permiso especial que hace que cuando se ha establecido ejecución, el proceso resultante asumirá la identidad del usuario dado en la clase de usuario (propietario del elemento). Corresponde al primer dígito del conjunto octal de permisos de los cuatro que hay. Un ejemplo para ver cómo funciona sería creando un programa en C que me indique cuál es el valor del \verb|UID| efectivo (permisos con los que ejecuta el usuario) y real (permisos de ejecución reales de ese usuario).
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.9\linewidth]{Recursos/muestraUID.png}
	\end{figure}
	Ahora, le otorgamos permisos a \verb|root| para comprobar cómo varía el valor del \verb|UID|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/rootUID.png}
	\end{figure}
	
	\subsection{Listas de acceso de control}
	Volvemos a crear dos usuarios nuevos y lo asignamos cada uno a un grupo nuevo distinto, de la misma manera que se ha hecho al comienzo de esta sección. Iniciando sesión en el \verb|userA|, creamos el directorio con solo permisos de lectura y acceso, el cuál va a contener un fichero con solo permiso de lectura para el usuario \verb|root|.\\\\
	Ahora, mediante el uso de la utilidad \verb|ACL|, damos permisos de lectura únicamente al usuario \verb|userB| con el comando \verb|sudo setfacl -m u:userB:r /home/userA/dirNuevo/fichUserA.txt| donde indicamos con la opción \verb|-m| que se quiere modificar la \verb|ACL| del fichero y señalamos el usuario que obtiene esos permisos:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/userA.png}
	\end{figure}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/setfaclUserB.png}
	\end{figure}
	\textbf{NOTA}: La utilidad no viene instalada en la máquina, hay que instalarla con \verb|sudo apt install acl|.
	\clearpage
	
	\subsection{Cuota de disco}
	Se trata de un límite establecido por el administrador del sistema que restringe ciertos aspectos del uso del sistema de archivos en los sistemas operativos modernos. El objetivo de la utilización de las cuotas de disco es limitar la asignación de espacio en el disco duro de una manera razonable \cite{quota}. Para activarla, tenemos que seguir estos pasos\cite{disk_quota}:
	\begin{enumerate}
		\item Instalamos la herramienta con el comando \verb|sudo apt install quota|.
		\item Una vez instalada, tenemos que editar el fichero \verb|/etc/fstab|, para activar las opciones de cuota en la partición \verb|/home|, tanto del usuario como para el grupo.
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.7\linewidth]{Recursos/fstabQuota.png}
		\end{figure}
		\item Remontamos la partición con \verb|mount -o remount /home| y reiniciamos los servicios demonios con \\ \verb|sudo systemctl daemon-reload|.
		\item Creamos el fichero con el índice de cuota con \verb|quotacheck -cum /home| y lo activamos con \verb|quotaon -v /home|.
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=\linewidth]{Recursos/quotaOn.png}
		\end{figure}
		Aparece un mensaje de aviso sobre el tipo de cuotas que puede ser ignorado ya que funciona sin problemas.
		\item Revisamos la configuración de las cuotas de cada usuario con \verb|edquota|, en el que aparece las columnas \verb|soft limit| o límite blando que se puede sobrepasar temporalmente, y \verb|hard limit| o límite duro que indica que no se puede sobrepasar ese límite:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.9\linewidth]{Recursos/quotaDansana.png}
			\caption{Cuota dansana}
		\end{figure}
	\end{enumerate}
	Un ejemplo donde se puede ver perfectamente su funcionamiento es modificando uno de los ficheros anteriores de los usuarios y estableciendo un límite de cuota tanto duro como blando, y ocupando el espacio disponible hasta ver el mensaje de \verb|Disk quota exceeded|. Para el límite blando, se nos otorga un periodo de 7 días hasta bloquear la escritura en disco.
	
	\subsection{Autoría /tmp}
	La auditoría no proporciona seguridad adicional a su sistema; más bien, puede utilizarse para descubrir violaciones de las políticas de seguridad utilizadas en su sistema. Por ello, para realizar este tipo de operaciones, la herramienta \verb|audit| que nos muestra esta información acerca de cualquier evento:
	\begin{itemize}
		\item Instalamos el servicio con \verb|sudo apt install auditd| y lo arrancamos tal y como hemos visto en el apartado de \verb|Servicios del sistema|.
		\item Después, creamos una nueva regla de auditoría para ese directorio con el comando \\ \verb|sudo auditctl -w /tmp -p rwxa|, donde se indica la carpeta a auditar y las operaciones que se auditan. Comprobamos que se ha agregado correctamente con \verb|sudo auditctl -l|.
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.7\linewidth]{Recursos/auditoriaTMP.png}
		\end{figure}
		\item Por último, realizaremos una prueba para ver cuál es contenido del reporte tras crear un fichero en ese directorio y ver su contenido:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.9\linewidth]{Recursos/testAudit.png}
		\end{figure}
		El resultado se puede ver en la última línea, que aparece repetida debido a una comprobación anterior del reporte.
	\end{itemize}
	
	\subsection{Copia de seguridad}
	\subsubsection{dump}
	Consultando el manual, esta herramienta trabaja con sistemas de ficheros \verb|ext2, ext3, ext4| examinado su contenido y determinando qué archivos son necesarios hacer \verb|backup|. Se pueden almacenar tanto en el propio disco como en un medio externo. Después, para recuperar el \verb|backup|, la herramienta que se debe utilizar es \verb|restore| pasando como argumento el fichero \verb|backup|.\\\\
	Existen diferentes opciones a tener en cuenta para realizar la copia de seguridad:
	\begin{itemize}
		\item \textbf{-level}: Nivel de la copia, siendo 0 un copia completo del sistema de ficheros.
		\item \textbf{-f}: El fichero donde queremos tener la copia de seguridad.
		\item \textbf{-u}: Actualiza el historial de copias \verb|/etc/dumpdates|.
		\item \textbf{-z}: Activación del modo compresión de la copia.
	\end{itemize}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.6\linewidth]{Recursos/dump.png}
	\end{figure}
	
	\subsubsection{tar}
	Conocida herramienta para empaquetar y comprimir archivos o directorios en un fichero. Añadir que con el mismo comando podemos también desempaquetar y restaurar los archivos en los discos. Con \verb|tar| podemos preservar los metadatos de los archivos originales, permisos, propiedad o enlaces simbólicos. Esto es muy importante a la hora de realizar copias de seguridad o permitir restaurar los contenidos respetando sus propiedades originales.\\\\
	Las \verb|flags| más utilizadas son las siguientes:
	\begin{itemize}
		\item \textbf{-c}: Indica la creación de un archivo.
		\item \textbf{-v}: Muestra todo lo que se está empaquetando.
		\item \textbf{-f}: Especifica el nombre del archivo comprimido.
		\item \textbf{-x}: Indica que se quiere extraer. 
	\end{itemize}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.9\linewidth]{Recursos/tar.png}
	\end{figure}
	
	\subsubsection{rsync}
	Es una herramienta de sincronización de archivos local y remota, de forma que podemos transferir ficheros de manera eficiente. Utiliza el algoritmo de transferencia delta que minimiza la transferencia de datos al copiar solo las secciones de un archivo que se han actualizado. Admite la copia de enlaces, dispositivos, propietarios, grupos y permisos.\\\\
	Los parámetros más comunes son:
	\begin{itemize}
		\item \textbf{-t}: Indicamos que es de forma recursiva.
		\item \textbf{-a}: Para copiar recursivamente en un directorio, con el añadido de mantener privilegios, permisos y fechas de los ficheros y directorios.
		\item \textbf{-z}: Copiado de forma comprimida.
		\item \textbf{-t}: Preservamos el tiempo de modificación de los archivos.
	\end{itemize}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.9\linewidth]{Recursos/rsync.png}
	\end{figure}
	\clearpage
	
	\section{Autenticación. Seguridad. Control de Servicios.}
	\subsection{PAM}
	En Linux, la autenticación de los usuarios en el sistema está estandarizado mediante el uso de \verb|PAM|. Proporciona un mecanismo para añadir autenticación a los programas mediante el uso de llamadas a las bibliotecas de funciones \verb|PAM|.\\
	El uso de diferentes módulos para cada servicio facilita que cada uno de ellos no tenga que implementar el mecanismo de acceso, sino simplemente pasar las credenciales a \verb|PAM| y este se encargue de indicar si el usuario tiene acceso a no.
	
	\subsubsection{Claves fuertes}
	El comando \verb|passwd| es uno de los que sí usan \verb|PAM| a la hora de crear las contraseñas, ya que en vez comunicarse con los ficheros \verb|/etc/passwd| y \verb|/etc/shadow|, hace una llamada al sistema \verb|PAM| y recibe las instrucciones del fichero \verb|/etc/pam.d/password|, donde realmente tiene su configuración en \verb|/etc/pam.d/common-password|. Comprendido esto, modificaremos este fichero para obligar a los nuevos usuarios a que la nueva contraseña que asignen tenga estos criterios:
	\begin{itemize}
		\item Permitir que, en caso de fallo, sólo reintente 2 veces.
		\item Obligatoriedad de contener al menos 1 carácter numérico, 1 carácter mayúscula y 1 carácter minúscula.
		\item Que no se utilicen palabras claves ya usadas, o que estén en un diccionario.
	\end{itemize}
	Antes de comenzar, \textbf{IMPORTANTE} hacer copia del fichero \verb|/etc/pam.d/password| porque si se comenten errores se puede bloquear los cambios de clave y habrá que formatear la máquina. También, es conveniente tener una sesión \verb|root| abierta en caso de problemas.\\\\
	Este sería el fichero \verb|/etc/pam.d/common-password| actualizado para conseguir cumplir esos criterios:
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.6\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/common-password.png}
		\end{minipage}\hfill
		\begin{minipage}{0.35\textwidth}
			\begin{itemize}
				\item En el primer módulo, \verb|libpam-pwquality|, indicamos el número de reintentos que tiene el usuario al cambiar la clave y cómo tiene que ser esa clave.
				\item En el segundo módulo, \verb|libpam-pwhistory|, conseguimos que se almacene las 5 últimas contraseñas.
			\end{itemize}
		\end{minipage}
	\end{figure}
	
	\textit{NOTA}: En el caso de perder o dañar dicho archivo y sí tener \verb|backup|, habrá que reiniciar la máquina virtual e ir al CD de \verb|Ubuntu Server| y desde el shell recuperar el fichero.
	
	\clearpage
	
	\subsubsection{Control de acceso por hora y por terminal}
	Siguiendo con el servicio \verb|PAM|, procedemos a cambiar el \verb|login| de nuestra máquina para agregar las siguientes restricciones, a través del fichero \verb|/etc/security/time.conf| que configura las reglas del módulo \verb|pam_time| encargado de la autenticación de un usuario en el sistema:
	\begin{itemize}
		\item Un usuario cualquiera (por ejemplo \verb|userA|) no pueda trabajar de 11:30h a 11:40h.
		\item Que ese mismo usuario no se pueda conectar a la consola.
		\item Y además, pueda acceder al resto de consolas que no sea la \verb|tty1|.
	\end{itemize}
	
	En el fichero, cada línea tiene que tener esta estructura: \verb|services;ttys;users;times|. \\\\ \textbf{IMPORTANTE}: Al igual que antes, hay que hacer copia de los ficheros que vayamos a cambiar en caso de fallo.
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.9\linewidth]{Recursos/timeConf.png}
	\end{figure}
	
	\subsection{Crontabd y atd}
	\subsubsection{Crontabd}
	Se trata de un servicio demonio que permite programar tareas automáticas para que se ejecuten de forma periódica. Para asignar un nueva tarea, lanzamos el comando \verb|crontab -e| donde indicamos primero cada cuanto se va a lanzar el script. \label{cron}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/crontab.png}
	\end{figure}
	
	\subsubsection{atd}
	La orden \verb|at| ejecuta un programa en un momento específico en el futuro. Toma el tiempo y la fecha deseados como parámetros de línea de comandos, y el comando a ejecutar en su entrada estándar. Ejecutará el programa como si hubiese ingresado en la consola.
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/at.png}
	\end{figure}
	
	\subsection{Seguimiento de la ejecución de servicios}
	Para ver los resultados el servicio demonio \verb|crond| en el registro \verb|rsyslogd|, hay que activar el registro y editar su configuración añadiendo la regla de que los \verb|logs| del servicio aparezcan en el registro. La línea que hay que añadir es \verb|cron.*	/var/log/cron.log| y reiniciar tanto el servicio \verb|cron| y el \verb|rsyslog|.
	
	\clearpage


	\section{Administración del Software. Herramientas de Desarrollo.}
	\subsection{Administración del Software}
	\subsubsection{Instalación de aplicaciones precompiladas}
	Nos piden instalar la herramienta \verb|apt-rdepends| (con \verb|sudo apt install apt-rdepends|) para obtener las dependencias de las aplicaciones que necesitemos utilizar, como es el caso del compilador \verb|gcc|, para programas escritos en \verb|C|. Mirando el manual, el comando para ver las dependencias del compilador es: \verb|apt-depends gcc|. Como la salida recibida aparece demasiada información, lo que haremos es redirigir la salida a un fichero, desde el que podremos ver todos los paquetes se necesitan:
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.55\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/dependenciasGCC.png}
		\end{minipage}\hfill
		\begin{minipage}{0.45\textwidth}
			\begin{itemize}
				\item En las primeras filas, se nos muestra las dependencias de la aplicación indicada, \verb|gcc|, con su versión más reciente.
				\item Y para el resto de filas, las dependencias de esos paquetes y, a su vez, las dependencias de esas dependencias.
			\end{itemize}
		\end{minipage}
	\end{figure}
	Otra forma rápida de comprobar si tenemos los paquetes necesarios para instalar cualquier aplicación, es realización directamente la instalación de esa aplicación primero, ya que \verb|apt| se encarga de comprobar y gestionar las dependencias. Si falta alguna de ellas, no nos dejará instalarlo y se nos mostrará la(s) dependencia(s) que faltan por instalar.\\\\
	Después de haberlo instalado correctamente con \verb|sudo apt install gcc|, descargamos \verb|git|, gestor de versiones, siguiendo la documentación oficial de la herramienta \cite{git} y comprobando sus dependencias.
	\clearpage
	\subsubsection{Reinstalación curl desde su código fuente}
	Cuando hemos instalado en el bloque anterior \verb|Ubuntu Server|, se instaló junto a él \verb|curl|, empleado para transferir información desde o hacia un servidor usando una \verb|URL|. Como vamos a aprender a instalar aplicaciones desde su código fuente, lo que haremos primero es desinstalarla con \verb|apt-get|:
	\begin{itemize}
		\item Antes de eliminar cualquier herramienta, hay que asegurarse si vamos a eliminarla pero mantiene los ficheros de configuración (\verb|remove|), o por el contrario, queremos una eliminación completa (\verb|purge|). Como vamos a reinstalarlo en el sistema, habría que usar la primera opción:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.9\linewidth]{Recursos/removeCURL.png}
		\end{figure}
		\item Después, clonamos el repositorio con toda la información acerca de \verb|curl|:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.9\linewidth]{Recursos/gitCURL.png}
		\end{figure}
		\item Las instrucciones se ubican en \verb|curl/README.md|, que leyendo el contenido del fichero, vemos que hay un apartado que indica acerca de la instalación de \verb|git|. En él, se indica el apartado de la documentación dónde explican cómo instalar \verb|curl| desde el repositorio \verb|git|, leyendo \verb|GIT-INFO.md|:
		\begin{figure}[H]
			\centering
			\begin{minipage}{0.55\textwidth}
				\centering
				\includegraphics[width=\linewidth]{Recursos/autoreconf.png}
			\end{minipage}\hfill
			\begin{minipage}{0.45\textwidth}
				\begin{itemize}
					\item \verb|autoreconf|: Es una utilidad del sistema \verb|Autotools| que regenera los \verb|scripts| del sistema de compilación de un proyecto de software, ejecutando varias herramientas en orden de \verb|Autotools| para conseguirlo. Su objetivo es construir el fichero \verb|configure|, que su función es comprobar el sistema si existen las dependencias necesarias y verifica las herramientas que se necesitan en la compilación. Por defecto, no está instalado en el sistema, por lo que habrá que lanzar el comando \verb|sudo apt install autoreconf|.
				\end{itemize}
			\end{minipage}
		\end{figure}
		\clearpage
		\item \verb|./configure --with-openssl|: Por una parte, tenemos la ejecución del \verb|script| creado en el paso anterior para crear el \verb|Makefile| a partir de la búsqueda para encontrar ciertas utilidades en el sistema, como el compilador \verb|C|, la ubicación de \verb|make|, etc. Por otra parte, se agrega la opción que aparece al lado para que en la compilación de \verb|curl| haya soporte con \verb|OpenSSL| para permitir una comunicación segura.
		
		Al terminar, se nos muestra la información que aparece en la figura:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.9\linewidth]{Recursos/configureCurl.png}
		\end{figure}
		
		\item \verb|make|: Por último, solo tendremos que lanzar el comando \verb|make| que se encargará de construir el programa haciendo uso del \verb|Makefile|. Es posible que no venga instalada la herramienta y haya que lanzar el comando \verb|sudo apt install make|:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.8\linewidth]{Recursos/installMake.png}
		\end{figure}
	\end{itemize}
	
	Para verificar si está bien instalada la aplicación, vamos a lanzar el programa que se encuentra en \verb|curl/src/curl| pasándole una dirección web:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=\linewidth]{Recursos/verCurl.png}
	\end{figure}
	Como vemos, nos devuelve el contenido de la página \verb|gui.inf.uva.es|, verificando que funciona correctamente.
	
	\subsubsection{Actualización del sistema}
	Una de las primeras tareas a realizar siempre cuando instalamos un sistema operativo es actualizar con los nuevos parches y versiones que existen desde que se publico el medio de instalación usado.
	
	Simplemente, usamos \verb|sudo apt-get update| para obtener las actualizaciones y \verb|sudo apt-get upgrade| para descargarlas e instalarlas. Evidentemente, si solo se hace \verb|upgrade| sin previamente haber hecho \verb|update|, no se instalará las actualizaciones más recientes.
	
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/update.png}
		\end{minipage}\hfill
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/upgrade.png}
		\end{minipage}
	\end{figure}
	
	\subsubsection{Nuevas versiones del núcleo Linux}
	El último punto de la sección, se aborda el concepto de los \verb|Tarballs|. Se tratan de unos archivos que contiene múltiples ficheros y directorios en un solo archivo. Son especialmente útiles para realizar copias de seguridad, distribuir software o archivos. Además, son una forma común de distribuir software en Linux \cite{TecnoBitsTarball}. \\
	
	Para llevar a cabo la tarea de determinar el nombre del paquete que contiene el
	núcleo, tenemos que averiguar primero su versión con \verb|cat /proc/version| o \verb|uname -r|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=\linewidth]{Recursos/version.png}
	\end{figure}
	Nos indica que se está empleando la \verb|6.8.0-86-generic|, por lo que iremos al directorio \verb|/boot| que es donde se encontrará los ficheros del arranque.
	Ahora, descargamos con \verb|curl| que hemos descargado y compilado el código fuente de esa misma versión en forma de \verb|tarball|. El repositorio usado se localiza en \\
	\verb|https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.8.tar.xz|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.95\linewidth]{Recursos/tarball.png}
	\end{figure}
	\textit{NOTA}: La razón de usar la extensión \verb|.xz| en vez de \verb|.gz| se basa en el tamaño del núcleo de Linux.\\
	
	Por último, vamos a comprobar el contenido del fichero comprimido, descomprimiendolo primero con el comando \verb|tar -xvf linux-6.8.tar.xz|. Cuando haya terminado, el contenido que se nos mostrará será el siguiente:
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.45\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/nucleo.png}
		\end{minipage}\hfill
		\begin{minipage}{0.55\textwidth}
			\begin{itemize}
				\item \textbf{Lógica central}: \verb|arch|, \verb|init|, \verb|kernel| y \verb|mm|
				\item \textbf{Hardware y Controladores}: \verb|drivers|, \verb|block| y \verb|sound|
				\item \textbf{Conectividad y Almacenamiento}: \verb|net| y \verb|fs|
				\item \textbf{Seguridad y Características Avanzadas}: \verb|security|, \verb|crypto|, \verb|virt|, \verb|ipc| y \verb|io_uring|
				\item \textbf{Herramientas y Soporte}: \verb|include|, \verb|lib|, \verb|scripts|, \verb|tools|, \verb|Documentation|, \verb|samples|, \verb|rust|
				\item \verb|Ficheros importantes|: \verb|Makefile|, \verb|Kconfig|, \verb|COPYING|, \verb|MAINTAINERS| y \verb|CREDITS|
			\end{itemize}
		\end{minipage}
	\end{figure}	
	
	\subsection{Herramientas de Desarrollo}
	\subsubsection{Shell script avanzados}
	Un \verb|shell script| es un programa creado con instrucciones que son ejecutadas por un \verb|shell| de Linux o Unix. Necesita un programa que entienda los comandos y estructuras que contiene y esto se suele poner en la primera línea del programa (\verb|#!/bin/bash|) \cite{shell}. 
	
	Una vez definido el concepto, procedemos a escribir el programa que nos devuelva los datos pedidos:
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/usuarios1.png}
		\end{minipage}\hfill
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/usuarios2.png}
		\end{minipage}
	\end{figure}
	
	Comprobamos su funcionamiento, después otorgarle permisos de ejecución con \verb|sudo chmod +x usuarios.sh|, y estos son los resultados que nos imprime (redirigiendo la salida a un fichero de texto, ya que sino no es posible verlo al completo):
	
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/salida1.png}
		\end{minipage}\hfill
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/salida2.png}
		\end{minipage}
	\end{figure}
	
	\subsubsection{Creación de una aplicación con lenguaje de alto nivel}
	Para terminar con está sección, vamos un perfilado de un programa que se encargue de leer los datos de un fichero de \verb|log| qu contiene información procedente de \verb|Apache Web Server| y de \verb|Internet Information Server|. Además, crearemos un \verb|Makefile| que se encargue de la actualización del ejecutable de la aplicación. Un \verb|Makefile| contiene un conjunto de instrucciones que se usan para ayudar a decidir qué partes de un programa grande necesitan ser recompiladas \cite{makefile}.\\
	
	Lo primero que nos piden es analizar el formato de los ficheros de \verb|log| de \verb|d100.log| y \verb|da-11-16.ipntld.log|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.65\linewidth]{Recursos/d100.png}
	\end{figure}
	\begin{itemize}
		\item Según su estructura, los ficheros siguen el formato estándar \verb|NCSA Combined Log Format|, que es el formato por defecto y más utilizado por \verb|Apache Web Server|.
		\item Tomemos la primera línea del fichero \verb|d100.log| para diseccionarla. Cada espacio separa un campo diferente:
		\begin{itemize}
			\item \verb|136.199.199.88|: IP del Cliente
			\item \verb|-|: Identidad (\verb|RFC 1413|)
			\item \verb|-|: Usuario
			\item \verb|[17/Nov/2012:03:00:27 +0100]|: Fecha y hora
			\item \verb|GET /index.php HTTP/1.1|: Petición
			\item \verb|200|: Código de estado
			\item \verb|4882|: Tamaño
			\item \verb|"-"|: Referer
			\item \verb|"Mozilla/5.0 ..."|: User Agent
		\end{itemize}
	\end{itemize}
	Podemos concluir que el fichero \verb|d100.log| muestra la actividad normal de un servidor web:
	\begin{enumerate}
		\item Vemos tráfico de 3 sistemas operativos distintos (según su dirección IP)
		\item Vemos un cliente antiguo o bot (IP 213.60...) buscando archivos de configuración estándar (favicon, robots.txt) que no existen, generando errores 404.
		\item Vemos un usuario recurrente (IP 83.33...) que aprovecha bien la caché del navegador (muchos códigos 304), lo que reduce la carga del servidor.
	\end{enumerate}
	
	
	Después de este análisis, construimos un programa que lea el fichero \verb|log| y determine la dirección que más consultas ha hecho al servidor, la cantidad de bytes que se han descargado tanto por cliente conectado como por hora. Cuando lo tengamos, crearemos el fichero \verb|Makefile| para la aplicación:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.85\linewidth]{Recursos/makefile.png}
	\end{figure}
	
	Como se puede observar, hemos creado una regla que realiza un perfilado automático y lo guarda en un fichero de texto con todo el análisis. Hay que usar el fichero \verb|log da-11-16.ipntld.log|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.85\linewidth]{Recursos/make.png}
	\end{figure}
	
	\clearpage
	
	
	\section{Administración avanzada de servicios}
	\subsection{Niveles de ejecución (Run-level)}
	En entornos \verb|UNIX/LINUX|, los niveles de ejecución son aquellos estados que definen qué servicios del sistema están funcionando y se identifican por números \cite{runlevels}.\\
	
	Como bien se menciona, en la actualidad, se han sustituido los \verb|run-level| por \verb|targets| (realizamos esta tarea en \ref{target}). En nuestro sistema, investigando los \verb|targets| que existen en nuestra máquina, lanzamos el comando \verb|ls -l /etc/systemd/system|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=\linewidth]{Recursos/targets.png}
	\end{figure}
	Ahora, con ayuda del manual de Linux (\verb|man runlevel|, \verb|man systemd| y \verb|man systemd.target|) ponemos en práctica los niveles de ejecución del sistema:
	\begin{itemize}
		\item Para determinar el \verb|target| por defecto que se encuentra, usamos el comando \verb|systemctl get-default|:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.7\linewidth]{Recursos/targetDefault.png}
		\end{figure}
		El que aparece por defecto, es el \verb|multi-user.target|, que es el que cambiamos en \ref{target}.
		\item Ahora, pasamos al nivel \verb|monousuario| o el antiguo nivel 1, que corresponde a \verb|rescue.target|. En este modo, el sistema cerrará los servicios de red y gráficos, dejándonos solos en una consola de texto:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.7\linewidth]{Recursos/monousuario.png}
		\end{figure}
		\item Volvemos al modo anterior, con el mismo comando cambiando el \verb|target|.
	\end{itemize}
	
	\subsection{Creación de nuevos servicios}
	Una vez que conocemos los distintos \verb|targets| y servicios que existen en el sistema (Bloque 1), vamos a crear nuestro propio servicio que se encargue de montar un disco sobre un dispositivo \verb|loop| cada vez que se inicie el sistema.\\
	
	Primero, creamos el disco sobre un fichero (como en el Bloque 1) y montar un sistema de ficheros dentro de él:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.9\linewidth]{Recursos/disk.png}
	\end{figure}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.9\linewidth]{Recursos/diskEXT4.png}
	\end{figure}
	
	Creamos el fichero en \verb|/root/.scripts/inicia_disco.sh| y le otorgamos permisos de ejecución con el comando \verb|chmod +x inicia_disco.sh|. Después, creamos el fichero con el servicio en \\ \verb|/etc/systemd/system/inicia_mi_vol.service| y lo habilitamos con \verb|systemctl enable inicia_mi_vol.service|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=\linewidth]{Recursos/servicioIniciado.png}
	\end{figure}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=\linewidth]{Recursos/dfLoop40.png}
	\end{figure}
	
	\subsection{Servidor Web}
	Continuando con esta sección, vamos a instalar y configurar un servidor web en nuestra máquina, concretamente el paquete \verb|nginx|. Para ello, primero comprobamos si existe alguna actualización y instalamos dicho paquete:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.9\linewidth]{Recursos/nginxInstall.png}
	\end{figure}
	Ahora, comprobamos con la herramienta \verb|curl|, si funciona correctamente el funcionamiento local (\verb|localhost|):
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/localhostCurl.png}
	\end{figure}
	Como se puede apreciar en el código \verb|HTML|, se puede ver la página de bienvenida de \verb|nginx|, confirmando que el servicio funciona correctamente.
	\clearpage
	Siguiendo la documentación oficial de \verb|nginx| \cite{nginx_docs} para saber cómo configurar el servicio web, vemos que se nos menciona el fichero de configuración principal \verb|/etc/nginx/nginx.conf| que importa distintos módulos para desempeñar distintas funciones. Además, en el directorio \verb|/var/log/nginx|, se ubican los distintos \verb|logs| o registros que son necesarios tener en cuenta para auditar su funcionamiento.\\
	
	Lo siguiente, es agregar en el directorio \verb|/var/www/html| un par de páginas \verb|HTML| con enlaces a ficheros para descargar con imágenes que visualizar. 
	Cuando estén, accedemos a esos ficheros \verb|HTML| con \verb|curl| y vemos como han cambiado los fichero de registro anteriores:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.9\linewidth]{Recursos/logNginx.png}
	\end{figure}
	Se muestra en las dos últimas líneas el acceso a las páginas \verb|HTML| indicadas.\\
	
	Por último, vamos poner a prueba la seguridad de nuestro servicio web. Le he pedido a un compañero que acceda a mi servicio web lanzando el comando \verb|curl 10.0.38.3|, que es mi dirección IP:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.9\linewidth]{Recursos/curlIP.jpg}
	\end{figure}
	Como bien se aprecia, se puede demostrar lo que nos indica el enunciado de que por defecto, \verb|Ubuntu| no trae activados los cortafuegos, así que mi compañero ha podido conectarse a mi servicio web.\\
	
	Para activar el \verb|firewall|, utilizamos el comando \verb|sudo ufw enable| que interactuará con \verb|iptables| de nuestra máquina:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.9\linewidth]{Recursos/ufw.png}
	\end{figure}
	La política por defecto es que rechazar todas las conexiones entrantes y se puede comprobar si desde otra máquina intentamos conectarnos a la máquina virtual, por ejemplo mediante \verb|ssh|.\\
	
	Para permitir que se puedan realizar conexiones \verb|SSH|, tenemos que poner el siguiente comando: \\ \verb|sudo iptables -I INPUT -p tcp --dport 22 -j ACCEPT|:
	\begin{itemize}
		\item \verb|-I INPUT|: Insertar al principio de la cadena de entrada
		\item \verb|-p tcp|: Protocolo TCP
		\item \verb|--dport 22|: Puerto destino 22
		\item \verb|-j ACCEPT|: Aceptar paquete
	\end{itemize}
	Y para el servicio \verb|HTTP|, el comando será: \verb|sudo iptables -I INPUT -p tcp --dport 80 -j ACCEPT|

	\subsection{XWindow}
	El \verb|X Window System|, también conocido como \verb|X Windows|, es un sistema de ventanas que proporciona una infraestructura para la creación y manipulación de interfaces gráficas de usuario en sistemas \verb|UNIX| \cite{xwindow}. Se realizará una instalación mínima con los siguientes paquetes:
	\begin{itemize}
		\item \verb|xserver-xorg-core|: El corazón del sistema gráfico (el servidor)
		\item \verb|openbox|: Un gestor de ventanas ligero (para poder moverlas, cerrarlas, etc.)
		\item \verb|xinit|: Aplicación para iniciar el entorno gráfico XWindow
		\item \verb|xterm|: La terminal básica en modo gráfico
		\item \verb|slim|: Un gestor de inicio de sesión. Al instalar \verb|slim|, el sistema cambiará su comportamiento de arranque por defecto al \verb|runlevel| 5 (modo gráfico).
	\end{itemize}
	
	Ahora, iniciamos sesión como \verb|root| para arrancar el servidor, usando el comando \verb|X|. Como estamos en una máquina virtual, no hay manera de salir, por lo que habrá que iniciar sesión desde otra máquina mediante \verb|ssh| y matar el proceso. Al finalizarlo, nos aparecerá esto:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.95\linewidth]{Recursos/X.png}
	\end{figure}
	
	Por otro lado, se puede iniciar el gestor mediante el comando \verb|xinit| y lanzar un primer cliente que es normalmente \verb|xterm|. Leyendo la documentación acerca de ese comando \cite{xinit}, primero hay que configurar el fichero \verb|/root/.xinitrc| y agregar una línea con \verb|exec openbox-session|. Al ejecutar el servicio, se iniciará el gestor de ventanas \verb|Openbox|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.75\linewidth]{Recursos/xinit.png}
	\end{figure}
	
	Otros clientes del servicio se encuentran dentro del paquete \verb|x11-apps|, como \verb|xclock| (Un reloj analógico), \verb|xeyes| (Unos ojos que siguen el cursor) y \verb|xcalc| (Una calculadora científica).
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.85\linewidth]{Recursos/x11app.png}
	\end{figure}
	
	Como queremos hacer la prueba de ejecutar los clientes desde el servidor, tenemos que iniciar el servicio \verb|xinit| con la terminal \verb|xterm|, modificando el \verb|.xinitrc|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.85\linewidth]{Recursos/xterm.png}
	\end{figure}
	
	Y desde ahí, lanzamos el cliente \verb|xclock|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.85\linewidth]{Recursos/xclock.png}
	\end{figure}
	
	Para iniciarlos automáticamente, modificamos el fichero anterior y agregamos \verb|xclock -geometry| \\ \verb|150x150+10+10 &|, antes de lanzar el cliente \verb|xterm|. En el caso que queramos arrancar \verb|XWindow| con el \verb|script startx|, se escribe en la línea de comando \verb|startx| y lanza el fichero \verb|.xinitrc|.\\
	
	Cuando estamos en un entorno gráfico, tenemos que saber cómo funciona la lógica del servicio. Por una parte, tenemos el servidor que se encarga de mostrar los gráficos y capturar el teclado y el ratón; y por otra parte, tenemos el cliente que es la propia aplicación. Para saber dónde se están dibujando esos gráficos, imprimimos el valor de la variable \verb|$DISPLAY|. El resultado que obtenemos es \verb|:0|, que sigue el formato \verb|hostname:display_number.screen_number|. En este caso, significa que es en la máquina local y en el primer display físico.
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.85\linewidth]{Recursos/display.png}
	\end{figure}
	
	Para terminar con esta parte, vamos a ejecutar el cliente \verb|X| desde mi máquina local Linux. Para ello, desde mi terminal, se lanza el comando \verb|ssh -X -p 38031 dansana@virtual.lab.inf.uva.es| para conectarme a la máquina virtual, activando el \verb|X11 Forwarding| para que aparezca en mi pantalla. Una vez dentro, se ejecuta el servidor y se comprueba el valor \verb|$DISPLAY|, ya que nos indicará que el túnel gráfico funciona correctamente:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=\linewidth]{Recursos/localXterm.png}
	\end{figure}
	
	\clearpage

	\section{Monitorización}
	\subsection{El sistema de archivos virtual /proc}
	Se trata de pseudo sistema de ficheros que proporciona una interfaz con estructuras de datos del núcleo.  Se monta comúnmente en \verb|/proc|, por lo general, se monta automáticamente por el sistema, pero también se puede montar manualmente utilizando un comando como: \verb|mount -t proc proc /proc|. La mayoría de los archivos en el sistema de archivos \verb|proc| son de solo lectura, aunque hay ficheros que permiten escribir, por lo que se puede cambiar las variables del \verb|kernel| \cite{proc_man}. Este es un listado de todos los directorios y ficheros que contiene \verb|proc|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=\linewidth]{Recursos/proc.png}
	\end{figure}
	
	Una vez que hemos determinado la función que desempeña \verb|/proc|, vamos a ver la información que nos proporciona los distintos ficheros y directorios que contiene:
	\begin{itemize}
		\item \verb|/proc/cpuinfo|: Obtenemos información acerca de la \verb|CPU|:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=\linewidth]{Recursos/cpuinfo.png}
		\end{figure}
		Lo primero que se imprime, es el modelo del procesador y la cantidad de núcleos que están asignados a esta máquina. Además, podemos destacar la cantidad de \verb|flags| que se muestran, entre ellas, la \verb|flag hypervisor| que indica que estamos operando en un entorno virtualizado.
		\item \verb|/proc/filesystems|: Lista de sistemas soportados por el núcleo actual. Ya se explicó este fichero en \ref{filesystems}:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.4\linewidth]{Recursos/filesystems1.png}
		\end{figure}
		\item \verb|/proc/interrumpts|: Estadísticas actuales de las interrupciones:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.75\linewidth]{Recursos/interrumpts.png}
		\end{figure}
		Se muestra el uso extensivo de \verb|drivers| paravirtualizados como \verb|virtio| con soporte \verb|MSI-X|, lo que permite distribuir la carga de interrupciones de E/S (Red/Disco) eficientemente entre los 4 núcleos lógicos.
		\item \verb|/proc/meminfo|: Información detallada sobre el uso de memoria:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.4\linewidth]{Recursos/meminfo.png}
		\end{figure}
		Como se puede observar, se cuenta con 6 GB de RAM física que ahora mismo está  en un estado de muy baja carga (aprox. 91\% de memoria disponible). No existe presión de memoria, evidenciado por el nulo uso de la partición Swap (0 kB usados). La caché de disco es relativamente baja (340 MB), indicando poca actividad reciente de E/S de ficheros.
	\end{itemize}
	
	\subsection{Perfilado y traza de un proceso}
	Para ver y determinar acerca de la ejecución de un programa en nuestro sistema, creamos un fichero en \verb|C| que se encargue de leer un fichero de entrada, la transforme (en este caso convirtiendo todos sus caracteres en mayúsculas) y escriba el resultado. El programa en \verb|C|, es el siguiente:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.9\linewidth]{Recursos/procesamiento.png}
	\end{figure}
	
	Ahora, para comprobar su funcionamiento correcto, habría que crear un fichero lo suficientemente grande como para ver el tiempo que tarda en ejecutarse, realizar un perfilado del programa, hacer una traza de llamadas de las llamadas al sistema que hace y determinar las bibliotecas dinámicas que se usan.
	\begin{itemize}
		\item \verb|time|: La ejecución del programa muestra un comportamiento limitado por procesador. De los 28.58 segundos totales de ejecución, 28.54 segundos se gastaron en modo usuario (cálculo puro), mientras que apenas 0.03 segundos se dedicaron a llamadas al sistema (E/S). La eficiencia del uso de CPU fue del 99\%, indicando que el proceso no sufrió bloqueos significativos por espera de disco (I/O Wait), lo cual es consistente con el bajo número de fallos de página (76 minor, 0 major).
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.9\linewidth]{Recursos/time.png}
		\end{figure}
		\item \verb|gprof|: El análisis de perfilado con \verb|gprof| identifica inequívocamente a la función tarea como el punto crítico de rendimiento, consumiendo el 99.58\% del tiempo de CPU (28.13 segundos).
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.9\linewidth]{Recursos/gprof.png}
		\end{figure}
		\item \verb|strace|: Se registraron 2,444 llamadas al sistema \verb|read| y 2,443 a \verb|write|. Además, \verb|openat| y \verb|close| reflejan no solo la apertura de los ficheros de datos del usuario, sino también la carga transparente de las bibliotecas dinámicas necesarias.\\
		
		Las operaciones de escritura consumieron la mayor parte del tiempo de sistema (30.07\%), seguidas por la apertura de ficheros, lo cual es consistente con un programa intensivo en E/S secuencial.
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.7\linewidth]{Recursos/strace.png}
		\end{figure}
		\item \verb|ldd|: El análisis de dependencias dinámicas mediante \verb|ldd| confirma que el binario no es estático, sino que depende de las bibliotecas compartidas del sistema. Para \verb|libc.so.6|, es la biblioteca estándar de C, necesaria para las funciones de E/S (\verb|stdio.h|) y manipulación de caracteres (\verb|ctype.h|). Para \verb|ld-linux-x86-64.so.2|, es el enlazador dinámico responsable de cargar las dependencias en tiempo de ejecución. Para \verb|linux-vdso.so.1| es la biblioteca virtual del kernel para optimizar llamadas al sistema (vDSO) sin cambio de contexto completo.
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.9\linewidth]{Recursos/ldd.png}
		\end{figure}
	\end{itemize}
	\subsection{Monitorización}
	Para terminar con esta parte, vamos a crear un \verb|script| que actúe como un monitor que guarde información del sistema cada 2 minutos. El \verb|script| es el siguiente:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.9\linewidth]{Recursos/monitor.png}
	\end{figure}
	Le otorgamos permisos de ejecución como hemos hecho con el resto y como vimos en \ref{cron}, creamos una tarea que se irá ejecutando cada 2 minutos:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/crontabMonitor.png}
	\end{figure}
	
	\subsubsection{SAR}
	Se trata de una herramienta clásica de los sistemas \verb|UNIX| y \verb|GNU/Linux|, que se utiliza para recopilar, informar y guardar datos de la CPU, memoria y lectura/escritura del disco. El comando \verb|SAR| genera los informes sobre la marcha, además también se puede configurar para guardar dichos informes en ficheros de registro \cite{sar}.\\
	
	En mi caso, el comando \verb|SAR| ya venía instalado en mi máquina virtual, por lo que solo es necesario configurarlo para que se ejecute de la forma que piden:
	\begin{itemize}
		\item Lo primero es modificar el fichero de configuración de \verb|SAR| que se encuentra en \verb|/etc/default/sysstat| y activar la opción \verb|ENABLE| que habilita la recolección de datos:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.8\linewidth]{Recursos/sysstat.png}
		\end{figure}
		Una vez guardados los cambios, reiniciamos el servicio:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.8\linewidth]{Recursos/serviceSAR.png}
		\end{figure}
		\item Después, ejecutamos el comando \verb|sar -o datos.data 2 300| y esperamos 10 minutos. Para que se vea un poco de actividad, desde otra terminal se puede iniciar sesión y realizar tareas para que queden registradas:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.75\linewidth]{Recursos/sarEx.png}
		\end{figure}
		\item Cuando haya terminado, veremos los resultados con \verb|sar -f| ya que se trata de un archivo binario y no se puede leer con un editor de texto.
		\begin{itemize}
			\item \verb|Uso de CPU|: Podemos ver cómo el sistema principalmente está en estado de reposo, ya que hay cerca de un 100\% de los recursos disponibles (\verb|idle|)
			\begin{figure}[H]
				\setlength{\abovecaptionskip}{0cm}
				\setlength{\belowcaptionskip}{0cm}
				\centering
				\includegraphics[width=0.75\linewidth]{Recursos/cpuSAR.png}
			\end{figure}
			\item \verb|Longitud de la cola de procesos|: Relacionado con el punto anterior, el sistema se encuentra en un estado de inactividad. Esto se puede ver en la carga nula del sistema en ese momento (\verb|ldavg|):
			\begin{figure}[H]
				\setlength{\abovecaptionskip}{0cm}
				\setlength{\belowcaptionskip}{0cm}
				\centering
				\includegraphics[width=0.75\linewidth]{Recursos/cargaSAR.png}
			\end{figure}
			\item \verb|Bloques leídos/escritos en disco|: En este caso, de pueden ver que no hay actividad de lectura en el disco y que hay escritura periódica en forma de ráfagas, coincidiendo con los ciclos de vaciado de buffers del sistema de archivos.
			\begin{figure}[H]
				\setlength{\abovecaptionskip}{0cm}
				\setlength{\belowcaptionskip}{0cm}
				\centering
				\includegraphics[width=0.75\linewidth]{Recursos/esSAR.png}
			\end{figure}
			\item \verb|Actividad de Red|: Era de suponer que el sistema al estar inactivo, no hay apenas actividad de red
			\begin{figure}[H]
				\setlength{\abovecaptionskip}{0cm}
				\setlength{\belowcaptionskip}{0cm}
				\centering
				\includegraphics[width=0.75\linewidth]{Recursos/redSAR.png}
			\end{figure}
		\end{itemize}
	\end{itemize}
	
	\clearpage
	
	\section{Virtualización}
	\subsection{VirtualBox}
	\verb|VirtualBox| es una aplicación de virtualización multi-plataforma. Esto significa que amplía las capacidades de nuestra máquina, por lo que puede ejecutar múltiples sistemas operativos, dentro de múltiples máquinas virtuales al mismo tiempo \cite{VirtualBox}.
	\subsubsection{Instalación}
	Para realizar la instalación en la máquina virtual y después de haber actualizado el sistema, lanzamos el comando \verb|apt-get install virtualbox|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=\linewidth]{Recursos/installVirtualBox.png}
	\end{figure}
	
	\subsubsection{Servicio Virtualizado}
	Tras completar la instalación, procedemos a descargar e instalar un servicio virtualizado que nos servirá como máquina virtual. Se trata de un \verb|Linux FedoraCore 1| que obtendremos de la dirección IP \verb|10.0.38.250| y la guardaremos en el directorio \verb|home| del \verb|root|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=\linewidth]{Recursos/fc1.png}
	\end{figure}
	
	\subsubsection{Importación de un servicio}
	Desde el entorno gráfico que hemos visto en la sección, abrimos la aplicación de \verb|VirtualBox| para importar el servicio que hemos descargado:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.65\linewidth]{Recursos/virtualboxXinit.png}
	\end{figure}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.65\linewidth]{Recursos/virtualboxFC1.png}
	\end{figure}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.65\linewidth]{Recursos/virtualboxPreferencias.png}
	\end{figure}
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.65\linewidth]{Recursos/servicioImportado.png}
	\end{figure}
	Una vez importado, podemos eliminar el fichero que contenía el servicio para ahorrar espacio. Arrancamos la máquina e iniciamos sesión como \verb|root|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.6\linewidth]{Recursos/inicioMaquina.png}
	\end{figure}
	
	\subsubsection{Administración de una máquina virtual}
	Al igual que hemos en el primer bloque, probamos todas las opciones que existen en la máquina virtual. 
	\begin{itemize}
		\item Para pausar y reiniciar, tenemos que hacer clic en \verb|Máquina| con la máquina arrancada y hacer clic en las opciones correspondientes. Para apagar la máquina, es necesario hacerlo desde la opción \verb|Archivo -> Salir|:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.45\linewidth]{Recursos/maquinaOpciones.png}
		\end{figure}
		\item Para tomar una instantánea de la máquina y recuperar una, tenemos que ir al apartado de \verb|Instantánea| de la máquina:
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.75\linewidth]{Recursos/instantanea.png}
		\end{figure}
		Hacemos la prueba de agregar una nueva instantánea para luego recuperarla en caso de error. 
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.75\linewidth]{Recursos/inicioInstantanea.png}
		\end{figure}
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.75\linewidth]{Recursos/restaurarInstantanea.png}
		\end{figure}
	\end{itemize}
	Realizamos un \verb|clon| de la máquina en su estado actual dentro del apartado de \verb|Instantaneas| de la máquina: 
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/clon.png}
	\end{figure}
	Ahora bien, cuando creemos el \verb|clon| con copia enlazada, tenemos que indicar en la \verb|Política de dirección MAC| que se deben generar nuevas direcciones MAC:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/clon1.png}
	\end{figure}
	La diferencia principal es el tipo de clonación que se ha escogido: por un lado está la completa, que es una copia exacta de los ficheros; y la copia enlazada, que los archivos de las unidades de disco duro virtuales será vinculados a los archivos de disco duro virtual de la máquina virtual original.\\
	
	Borramos el \verb|backup| y hacemos una nueva clonación con copia enlazada. Al iniciar ambas máquinas a la vez, veremos que tardará más de lo normal debido a que necesita mayor cantidad recursos.
	
	\subsubsection{Administración de disco}
	Vamos a adentrarnos en el apartado del almacenamiento de las máquinas virtuales. Creamos en la sección de \verb|Almacenamiento| un nuevo disco duro para la máquina, con un tamaño pequeño. Es importante que se reserve de forma dinámica el espacio:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/fc1-1disk.png}
	\end{figure}
	Ahora, con la herramienta \verb|fdisk| y con \verb|mkfs| hacemos la partición y el sistema de ficheros, respectivamente:
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/fdiskFC.png}
		\end{minipage}\hfill
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/mkfsFC.png}
		\end{minipage}
	\end{figure}
	Por último, montamos la partición con \verb|mount| en \verb|/mnt|, por ejemplo:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/mountFC.png}
	\end{figure}
	
	Después, vamos a ver los distintos tipos de disco que soporta la aplicación, entre ellos \cite{VirtualBox_Storage}:
	\begin{itemize}
		\item \verb|Disk Images Files|: Empieza siendo muy pequeño y crece automáticamente a medida que el sistema invitado escribe datos en él, hasta llegar al límite máximo definido. Aunque inicialmente ahorra espacio, puede tener una ligera penalización de rendimiento mientras se expande.
		\item \verb|Differencing Images|: Se describe como un disco especial que solo almacena las diferencias respecto a otro disco "padre". Es la tecnología base que usa VirtualBox para las Instantáneas y los Clones Enlazados.
	\end{itemize}
	\subsubsection{Administración de red}
	En este apartado, vamos a conocer acerca de la configuración de red de las máquinas virtuales anidadas. Arrancamos ambas y comprobamos sus direcciones IP para realizar diferentes pruebas:
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/ipFC1.png}
		\end{minipage}\hfill
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/ipFC1.png}
		\end{minipage}
	\end{figure}
	Podemos ver como en ambos casos es la misma dirección y no se podrá hacer ninguna prueba de conexión entre ellas, debido a que está seleccionada la opción de red \verb|NAT|. Para que tengan distinta, tenemos que marcar la opción \verb|Red NAT|.
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/redNAT.png}
	\end{figure}
	Sin apagar las máquinas, cambiamos su configuración de red y reiniciamos sus servicios con \\ \verb|/etc/init.d/network restart|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/resetNetwork.png}
	\end{figure}
	Y ahora sí que se pueden ver porque tienen distinta dirección IP:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/ipDistintas.png}
	\end{figure}
	Podemos comprobarlo realizando un \verb|ping| y un \verb|ssh| entre máquinas:
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/pingFCs.png}
		\end{minipage}\hfill
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=\linewidth]{Recursos/sshFCs.png}
		\end{minipage}
	\end{figure}
	\subsection{Contenedores}
	\subsubsection{Docker}
	Para su instalación, ponemos el comando \verb|apt install docker.io| y comprobamos su versión e información del paquete con \verb|docker version| y \verb|docker info|:
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=0.9\linewidth]{Recursos/dockerVersion.png}
		\end{minipage}\hfill
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=0.8\linewidth]{Recursos/infoDocker.png}
		\end{minipage}
	\end{figure}
	Hacemos la prueba con la imagen de \verb|Ubuntu|, primero la descargamos con \verb|docker search ubuntu|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/searchUbuntu.png}
	\end{figure}
	Descargamos un \verb|Ubuntu| con lo mínimo con \verb|docker pull docker.io/ubuntu|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/dockerPull.png}
	\end{figure}
	Ahora lo podemos ejecutar con \verb|docker run -i -t docker.io/ubuntu|.
	\subsubsection{Administración}
	Si estamos dentro del contenedor, veremos que está anclado a un terminal. Se puede desanclar con la combinación \verb|Ctrl+P| y luego \verb|Ctrl+Q|. De esta manera, quedará en un segundo plano, que se podrá ver desde \verb|docker ps|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.8\linewidth]{Recursos/dockerPS.png}
	\end{figure}
	Para volverlo a atar, \verb|docker attach  nombre_del_contenedor|. Y para apagarlo es con \verb|exit| desde dentro, o \verb|docker kill| desde fuera.\\
	
	Luego, vamos a actualizar el contenedor desde el que nos encontramos e instalamos el servicio \verb|SSH|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=\linewidth]{Recursos/sshDocker.png}
	\end{figure}
	Lo habilitamos con \verb|service ssh start| y creamos un usuario en el contenedor para acceder por \verb|ssh|:
	\begin{figure}[H]
		\setlength{\abovecaptionskip}{0cm}
		\setlength{\belowcaptionskip}{0cm}
		\centering
		\includegraphics[width=0.7\linewidth]{Recursos/userSSH.png}
	\end{figure}
	Para saber la dirección IP del contenedor, tendríamos que usar \verb|ifconfig|. Sin embargo, al ser un comando viejo, no viene instalado, por que habrá que instalar el paquete que lo contiene con \verb|apt-get install net-tools|. Cuando lo tengamos, podremos hacer un \verb|ssh|:
	\begin{figure}[H]
		\centering
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=0.9\linewidth]{Recursos/ifconfigDocker.png}
		\end{minipage}\hfill
		\begin{minipage}{0.48\textwidth}
			\centering
			\includegraphics[width=0.8\linewidth]{Recursos/sshDocker1.png}
		\end{minipage}
	\end{figure}
	Para acabar, vamos a crear una nueva imagen del contenedor, siguiendo los pasos indicados:
	\begin{enumerate}
		\item Lo desacoplamos como hemos hecho hasta ahora y detenemos el contenedor
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.8\linewidth]{Recursos/stopDocker.png}
		\end{figure}
		\item Creamos la imagen nueva y reiniciamos el contenedor parado
		\begin{figure}[H]
			\setlength{\abovecaptionskip}{0cm}
			\setlength{\belowcaptionskip}{0cm}
			\centering
			\includegraphics[width=0.8\linewidth]{Recursos/newDocker.png}
		\end{figure}
	\end{enumerate}
	\clearpage
	
	\bibliographystyle{unsrt}
	\bibliography{bibliografia}
\end{document}